

# AES 加密



## 高级加密标准（英语：Advanced Encryption Standard，缩写：AES



## PKCS5Padding、PKCS7Padding 和NO Padding

PKCS7Padding跟PKCS5Padding的区别就在于数据填充方式，

PKCS7Padding是缺几个字节就补几个字节的0

PKCS5Padding是缺几个字节就补充几个字节的几，好比缺6个字节，就补充6个字节的6 。



## 加密五种加密模式

（1）ECB 模式（电子密码本模式：Electronic codebook）

ECB 是最简单的块密码加密模式，加密前根据加密块大小（如 AES 为 128 位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。
ECB 模式由于每块数据的加密是独立的因此加密和解密都可以并行计算。
ECB 模式最大的缺点是**相同的明文块会被加密成相同的密文块**，这种方法在某些环境下不能提供严格的数据保密性。

（2）CBC 模式（密码分组链接：Cipher-block chaining）

CBC 模式对于每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密。第一个明文块与一个叫初始化向量的数据块异或。
CBC 模式相比 ECB 有更高的保密性，但由于对**每个数据块的加密依赖于前一个数据块的加密，所以加密无法并行**。
CBC 模式与 ECB 一样在加密前需要对数据进行填充，不是很适合对流数据进行加密。 


（3）CTR 模式（计算器模式：Counter）

计算器模式不常见，在 CTR 模式中， 有一个自增的算子，这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。
这种加密方式简单快速，安全可靠，而且可以并行加密。
但是在计算器不能维持很长的情况下，密钥只能使用一次。


（4）CFB 模式（密文反馈：Cipher feedback）

CFB 能够将块密文（Block Cipher）转换为流密文（Stream Cipher）。
CFB 的加密工作分为两部分：先将前一段加密得到的密文再加密；接着将第 1 步加密得到的数据与当前段的明文异或。
由于加密流程和解密流程中被块加密器加密的数据是前一段密文，因此即使明文数据的长度不是加密块大小的整数倍也是不需要填充的，这保证了数据长度在加密前后是相同的。
**CFB 模式非常适合对流数据进行加密，解密可以并行计算。**


（5）OFB 模式（输出反馈：Output feedback）

OFB 是先用块加密器生成密钥流（Keystream），然后再将密钥流与明文流异或得到密文流，解密是先用块加密器生成密钥流，再将密钥流与密文流异或得到明文，由于异或操作的对称性所以加密和解密的流程是完全一样的。
**OFB 与 CFB 一样都非常适合对流数据的加密。**
OFB 由于加密和解密都依赖与前一段数据，所以加密和解密都不能并行。

## 关于密钥长度

（1）在进行 **AES** 加密时，**CryptoSwift** 会根据密钥的长度自动选择对应的加密算法（**AES128**, **AES192**, **AES256**）

- AES-128 = 16 bytes
- AES-192 = 24 bytes
- AES-256 = 32 bytes

（2）这里我们以 **ECB** 模式为例。由于密钥为 **16** 个字符（字节），则自动采用 **aes128** 加密。

（3）如果密钥长度不够 16、24 或 32 字节，可以使用 zeroPadding 将其补齐至 blockSize 的整数倍。

​	zeroPadding 补齐规则：
​	将长度补齐至 blockSize 参数的整数倍。比如我们将 blockSize 设置为 AES.blockSize（16）。

​	如果长度小于 16 字节：则尾部补 0，直到满足 16 字节。
​	如果长度大于等于 16 字节，小于 32 字节：则尾部补 0，直到满足 32 字节。
​	如果长度大于等于 32 字节，小于 48 字节：则尾部补 0，直到满足 48 字节。 以此类推......
​	这里还是以 ECB 模式为例，假设我们密钥只有 9 个字节，通过 zeroPadding 补齐到 16 个字节。
